#if  IG_C301 || IG_C302 || IG_C303 || TUANJIE_2022_3_OR_NEWER // Auto generated by AddMacroForInstantGameFiles.exe

using UnityEditor;
using UnityEngine;

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System;
#if UNITY_ADDRESSABLES
using UnityEditor.AddressableAssets;
#endif

namespace Unity.AutoStreaming
{
    [InitializeOnLoad]
    internal sealed class AutoStreamingCache
    {
        static AutoStreamingCache()
        {
            if (PlayerSettings.autoStreaming && !Directory.Exists(AutoStreamingSettings.autoStreamingDirectory))
                Directory.CreateDirectory(AutoStreamingSettings.autoStreamingDirectory);

        }

    }

    internal class ASUtilities
    {
        public static string GetPlatformSpecificResourcePath(string resourcePath)
        {
            // The platform-specific build target directory needs to be consistent between the C++ side and
            // the C# side. Ideally there should be an API that allows the C# package to inform the engine
            // of the directory, but I don't know yet how important/generic that API would be, so for now we
            // have to keep the implicit protocol between the engine and the C# package, meaning we should
            // call GetBuildTargetUniqueName() in C++ and BuildPipeline.GetBuildTargetName() in C# for the
            // consistent directory.
            string buildTargetName = BuildPipeline.GetBuildTargetName(EditorUserBuildSettings.activeBuildTarget);
            return Path.Combine(resourcePath, buildTargetName);
        }

        public static List<string> GetExistingAssetBundles(string resourcePath)
        {
            List<string> abPaths = new List<string>();

            DirectoryInfo dirInfo = new DirectoryInfo(GetPlatformSpecificResourcePath(resourcePath));
            if (dirInfo.Exists)
            {
                FileInfo[] files = dirInfo.GetFiles("*.abas");

                foreach (var file in files)
                {
                    abPaths.Add(file.FullName);
                }
            }
            return abPaths;
        }

        public static string GetRelativePath(string relativeTo, string path)
        {
            var uri = new Uri(relativeTo);
            var rel = Uri.UnescapeDataString(uri.MakeRelativeUri(new Uri(path)).ToString()).Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
            if (rel.Contains(Path.DirectorySeparatorChar.ToString()) == false)
            {
                rel = $".{ Path.DirectorySeparatorChar }{ rel }";
            }
            return rel;
        }

        static string sProjectRootPath = null;
        public static string GetProjectRootPath()
        {
            if (sProjectRootPath == null)
                sProjectRootPath = Path.GetFullPath(Path.Combine(Application.dataPath, "..")) + "\\";
            return sProjectRootPath;
        }
        public static string GetRelativePathIfInProjectFolder(string inPath)
        {
            if (string.IsNullOrWhiteSpace(inPath))
                return "";
            string fullPath = Path.GetFullPath(inPath);
            if (fullPath.StartsWith(GetProjectRootPath()))
                return GetRelativePath(GetProjectRootPath(), fullPath);
            return fullPath;
        }

        static readonly string k_AddressableAssetsPath = Path.Combine(AutoStreamingSettings.autoStreamingDirectory, "Addressable.txt");
        public static void GenerateAddressablePathsText()
        {
#if UNITY_ADDRESSABLES
            // This is a workaround for upgrading from old project which has no search mode for Addressable assets.
            if (!AutoStreamingSettings.searchMode.HasFlag(AutoStreamingSearchMode.AddressableAsset))
                AutoStreamingSettings.searchMode |= AutoStreamingSearchMode.AddressableAsset;

            // Parse AddressableAssetSettings to extract all the assets.
            var addressableAssetSettings = AddressableAssetSettingsDefaultObject.Settings;
            if (addressableAssetSettings == null)
                return;

            var paths = new HashSet<string>();
            foreach (var group in addressableAssetSettings.groups)
            {
                // Skip "Built In Data" group.
                if (group.Name.StartsWith("Built In Data"))
                    continue;

                foreach (var entry in group.entries)
                {
                    paths.Add(entry.AssetPath);
                }
            }

            if (paths.Count <= 0)
                return;

            // Check if "AutoStreamingCache" folder exists.
            if (!Directory.Exists(AutoStreamingSettings.autoStreamingDirectory))
                Directory.CreateDirectory(AutoStreamingSettings.autoStreamingDirectory);

            using (StreamWriter writer = new StreamWriter(k_AddressableAssetsPath))
            {
                writer.WriteLine(paths.Count);
                foreach (var path in paths)
                {
                    writer.WriteLine(path);
                }
            }
#else
            if (AutoStreamingSettings.searchMode.HasFlag(AutoStreamingSearchMode.AddressableAsset))
                AutoStreamingSettings.searchMode &= ~AutoStreamingSearchMode.AddressableAsset;

            if (File.Exists(k_AddressableAssetsPath))
                File.Delete(k_AddressableAssetsPath);
#endif //UNITY_ADDRESSABLES
        }
    }

    internal static class StreamingFiles
    {
        internal static int scenes_count;
        internal static long scenes_size;

        internal static int texture_count;
        internal static long texture_size;

        internal static int mesh_count;
        internal static long mesh_size;

        internal static int font_count;
        internal static long font_size;

        internal static int audio_count;
        internal static long audio_size;

        internal static int animation_count;
        internal static long animation_size;

        internal static int custom_count;
        internal static long custom_size;

        internal static int total_count;
        internal static long total_size;

        internal static long GetStreamingFilesSize(string streamingDir)
        {
            long totalSize = 0;
            DirectoryInfo dirInfo = new DirectoryInfo(streamingDir);
            if (dirInfo.Exists)
            {
                FileInfo[] files = dirInfo.GetFiles("*.abas");

                foreach (var file in files)
                {
                    totalSize += file.Length;
                }
                return totalSize;
            }
            return 0;
        }

        public static int GetStreamingFilesCount(string streamingDir)
        {
            DirectoryInfo dirInfo = new DirectoryInfo(streamingDir);
            if (dirInfo.Exists)
            {
                return dirInfo.GetFiles("*.abas").Length;
            }
            return 0;
        }

        internal static void RefreshInfo()
        {
            total_count = 0;
            total_size = 0;
            string platformSpecificPath = ASUtilities.GetPlatformSpecificResourcePath(ASBuildConstants.k_SceneABPath);
            scenes_count = GetStreamingFilesCount(platformSpecificPath);
            scenes_count = scenes_count > 0 ? scenes_count - 1 : 0;
            scenes_size = GetStreamingFilesSize(platformSpecificPath);

            total_count += scenes_count;
            total_size += scenes_size;

            platformSpecificPath = ASUtilities.GetPlatformSpecificResourcePath(ASBuildConstants.k_TextureABPath);
            texture_count = GetStreamingFilesCount(platformSpecificPath);
            texture_size = GetStreamingFilesSize(platformSpecificPath);

            total_count += texture_count;
            total_size += texture_size;

            mesh_count = GetStreamingFilesCount(ASBuildConstants.k_MeshABPath);
            mesh_size = GetStreamingFilesSize(ASBuildConstants.k_MeshABPath);

            total_count += mesh_count;
            total_size += mesh_size;

            font_count = GetStreamingFilesCount(ASBuildConstants.k_FontABPath);
            font_size = GetStreamingFilesSize(ASBuildConstants.k_FontABPath);

            total_count += font_count;
            total_size += font_size;

            audio_count = GetStreamingFilesCount(ASBuildConstants.k_AudioABPath);
            audio_size = GetStreamingFilesSize(ASBuildConstants.k_AudioABPath);

            total_count += audio_count;
            total_size += audio_size;

            animation_count = GetStreamingFilesCount(ASBuildConstants.k_AnimationABPath);
            animation_size = GetStreamingFilesSize(ASBuildConstants.k_AnimationABPath);

            total_count += animation_count;
            total_size += animation_size;

            custom_count = GetCustomFileCount();
            custom_size = GetCustomFileSize();

            total_count += custom_count;
            total_size += custom_size;
        }

        internal static void ClearUnusedTexABs()
        {
            string platformSpecificPath = ASUtilities.GetPlatformSpecificResourcePath(ASBuildConstants.k_TextureABPath);
            if (!Directory.Exists(platformSpecificPath))
                return;
            HashSet<string> absToKeep = new HashSet<string>();
            foreach (var tex in AutoStreamingSettings.textures)
            {
                if (tex.usePlaceholder)
                {
                    absToKeep.Add(AssetDatabase.AssetPathToGUID(tex.assetPath));
                }
            }

            var root = new DirectoryInfo(platformSpecificPath);
            var files = root.GetFiles();

            foreach (var file in files)
            {
                if (file.Extension.ToLower() == ".abas")
                {
                    if (!absToKeep.Contains(Path.GetFileNameWithoutExtension(file.FullName)))
                    {
                        File.Delete(file.FullName);
                        File.Delete(file.FullName + ".manifest");
                    }
                }
            }

            RefreshInfo();
        }

        internal static void ClearAllCacheFiles()
        {
            if (scenes_size > 0)
                Directory.Delete(ASUtilities.GetPlatformSpecificResourcePath(ASBuildConstants.k_SceneABPath), true);
            if (texture_size > 0)
                Directory.Delete(ASUtilities.GetPlatformSpecificResourcePath(ASBuildConstants.k_TextureABPath), true);
            if (mesh_size > 0)
                Directory.Delete(ASBuildConstants.k_MeshABPath, true);
            if (font_size > 0)
                Directory.Delete(ASBuildConstants.k_FontABPath, true);
            if (audio_size > 0)
                Directory.Delete(ASBuildConstants.k_AudioABPath, true);
            if (animation_size > 0)
                Directory.Delete(ASBuildConstants.k_AnimationABPath, true);

            RefreshInfo();
        }

        internal static long GetCustomFileSize()
        {
            long totalSize = 0;
            DirectoryInfo dirInfo = new DirectoryInfo(ASBuildConstants.k_CustomCloudAssetsPath);
            if (dirInfo.Exists)
            {
                FileInfo[] files = dirInfo.GetFiles("*", SearchOption.AllDirectories);

                foreach (var file in files)
                {
                    totalSize += file.Length;
                }
                return totalSize;

            }

            return 0;
        }

        internal static int GetCustomFileCount()
        {
            DirectoryInfo dirInfo = new DirectoryInfo(ASBuildConstants.k_CustomCloudAssetsPath);
            if (dirInfo.Exists)
            {
                return dirInfo.GetFiles("*", SearchOption.AllDirectories).Length;
            }
            return 0;
        }
    }
}

#endif  //  IG_C301 || IG_C302 || IG_C303 || TUANJIE_2022_3_OR_NEWER, Auto generated by AddMacroForInstantGameFiles.exe
